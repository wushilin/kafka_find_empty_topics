/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.wushilin.kafka.find.empty.topics

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import net.wushilin.props.EnvAwareProperties
import org.apache.kafka.clients.admin.AdminClient
import org.apache.kafka.clients.admin.DescribeTopicsOptions
import org.apache.kafka.clients.admin.ListTopicsOptions
import org.apache.kafka.clients.consumer.KafkaConsumer
import org.apache.kafka.common.TopicPartition
import java.nio.charset.StandardCharsets

class App : CliktCommand() {
    val clientConfig: String by option("-c", "--command-config", help="Kafka client config file").required()
    val out: String by option("-o", "--out-file", help="Output file").required()
    override fun run() {
        val props = EnvAwareProperties.fromPath(clientConfig)
        if(props["group.id"] == null) {
            props["group.id"] = "kafka-find-empty-topics-consumer-group"
        }
        props["key.deserializer"] = "org.apache.kafka.common.serialization.StringDeserializer"
        props["value.deserializer"] = "org.apache.kafka.common.serialization.StringDeserializer"

        val adminClient = AdminClient.create(props)
        val options = ListTopicsOptions()
        options.listInternal(false)
        options.timeoutMs(60000)
        val topicList = adminClient.listTopics(options).names().get()
        val consumer = KafkaConsumer <ByteArray, ByteArray>(props)

        val topicPartitionCountInfo = mutableMapOf<String, Int>()
        for(topic in topicList) {
            if(topic.startsWith("_")) {
                continue;
            }
            val describeOptions = DescribeTopicsOptions()
            describeOptions.timeoutMs(60000)
            describeOptions.includeAuthorizedOperations(false)
            val topicDetails = adminClient.describeTopics(listOf(topic), describeOptions).allTopicNames().get()
            for((key, value) in topicDetails) {
                val partitions = value.partitions().size
                val name = value.name()
                topicPartitionCountInfo[name] = partitions
            }
        }

        val result = mutableMapOf<String, Long>()
        for((topicName, partitionCount) in topicPartitionCountInfo) {
            val range = 0 until partitionCount
            val subscription = range.map {
                it ->
                TopicPartition(topicName, it)
            }.toList()
            consumer.assign(subscription)
            consumer.seekToBeginning(subscription)
            val begin= consumer.beginningOffsets(subscription)
            val end = consumer.endOffsets(subscription)
            var totalSum = 0L
            for((tp, endOffset) in end) {
                val beginOffset = begin[tp]!!
                totalSum += (endOffset - beginOffset)
            }
            result[topicName] = totalSum
        }

        var written = 0
        java.io.File(out).outputStream().use {
            for((topic, count) in result) {
                if(count == 0L) {
                    it.write("$topic, $count\n".toByteArray(StandardCharsets.UTF_8))
                    written++
                }
            }

            for((topic, count) in result) {
                if(count > 0L) {
                    it.write("$topic, $count\n".toByteArray(StandardCharsets.UTF_8))
                    written++
                }
            }
        }
        println("Written $written result to $out")
    }
}

fun main(args: Array<String>) = App().main(args)

